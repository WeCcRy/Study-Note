# HTML

## 1. src和href的区别

请求src资源时会下载指向资源并应用到文档内，会先暂停其他资源的下载和处理

请求href的时候会并行下载资源，且不会停止对文档的处理

综上，一般js文件等使用src请求，而css等文件使用href请求

## 2. HTML语义化标签

有利于seo和开发，还有一个是标签中的role

```html
<header></header>  头部
<nav></nav>  导航栏
<section></section>  区块（有语义化的div）
<main></main>  主要区域
<article></article>  主要内容
<aside></aside>  侧边栏
<footer></footer>  底部
```

## 3. DOCTYPE的作用

写在首行，为了告诉浏览器用什么样的文档类型解析文档，有标准模式和混杂模式，会影响CSS和js脚本的解析

`<!Doctype html>`的作用：`<!Doctype html>` 的作用就是让浏览器进入标准模式，使用最新的 HTML5 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。

其实还有个用于过渡两个模式的准标准模式

## 4. script中defer和async的作用

首先，不使用defer或async，就会立即加载并执行对应脚本，不会等待后续加载的文档元素，会阻塞后续文档的加载

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp)

defer是同步加载，但延迟执行。async是同步加载，立刻执行

如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的

## 5. 常用的meta标签

1. `<meta charset = "UTF-8"` 用来表示文档的编码类型
2. `<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">`
   1. `width viewport` ：宽度(数值/device-width)
   2. `height viewport` ：高度(数值/device-height)
   3. `initial-scale` ：初始缩放比例
   4. `maximum-scale` ：最大缩放比例
   5. `minimum-scale` ：最小缩放比例
   6. `user-scalable` ：是否允许用户缩放(yes/no）

## 6. H5的新功能

1. 语义化标签

2. 媒体标签：

   `<audio src='' controls(开启控制面板) autoplay(自动播放) loop='true'(是否循环)></audio>`

   `<video src='' poster='imgs/aa.jpg'(封面，默认视频首帧) controls></video>`

   `<source src='aa.mp4' type='video/mp4'></source>`,一般用于解决video中src无法解析的问题

3. 新的表单类型和表单属性

4. progress进度条，max表示完整进度，value表示当前进度

5. DOM操作，`document.querySelector()`,`document.querySelectorAll()`

6. Web存储，localStorage和sessionStorage

## 7. 行内元素和块级元素

- 行内元素有：`a b span img input select strong`；
- 块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p`；

## 8. Web Workder

为了解决JS的单线程问题，Web Worker提供了一个独立的worker线程。

Web Worker分为专用线程和共享线程，专用线程仅供创建worker的线程使用，共享线程可以由多个脚本使用

![](./webworker1.png)

​	![](./webworker2.png)

```js
// 页面js
<script>
    const worker = new Worker('./worker.js') // 引入worker脚本

    function calc() {
        const num = parseInt(document.getElementById('num').value)
        worker.postMessage(num) // 获取dom元素，并向worker发送数据
    }

    worker.onmessage = function (e) {
    	document.getElementById('result').innerHTML = e.data
    }
</script>

// worker.js
function calc(num) {
    let result = 0
    let startTime = performance.now()
    // 计算求和（模拟复杂计算）
    for (let i = 0; i <= num; i++) {
        result += i
    }
    // 由于是同步计算，在没计算完成之前下面的代码都无法执行
    const time = performance.now() - startTime
    console.log('总计算花费时间:', time)
    self.postMessage(result) // 将结果返回给调用线程
}

self.onmessage = function (e) {
    calc(e.data)  // worker进程接受到数据后，开始计算
}
```

webworker有同源要求限制，即同协议，同域名，同端口。可以通过Blob或importScripts引入外部脚本。worker线程内不存在dom对象，且和主线程之间的通过必须通过message传递。通过主线程调用terminate或worker线程调用close进行关闭。

## 9. label标签

可以将焦点转移到绑定的元素

```
// 两种方法，点击label元素均可以触发input
// 法一，使用for和name绑定
<label for="mobile">Number:</label>
<input type="text" id="mobile"/>

// 法二，直接将绑定元素放到label标签内
<label>Date:<input type="text"/></label>
```

## 10. head标签的作用

`<head>` 标签用于定义文档的头部，它是所有头部元素的容器。`<head>` 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。必须要用`<title>`

# CSS

## 选择器介绍

### 属性选择器

| 选择器        | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| [attr]        | 匹配带有一个名为*attr*的属性的元素。                         |
| [attr=value]  | 匹配带有一个名为*attr*的属性的元素，其值正为*value*。        |
| [attr~=value] | 匹配带有一个名为*attr*的属性的元素，其值正为*value*，或者匹配带有一个*attr*属性的元素，其值有一个或者更多，至少有一个和*value*匹配（值用空格分隔）。 |
| [attr^=value] | 匹配带有一个名为*attr*的属性的元素，其值开头为*value*子字符串。 |
| [attr&=value] | 匹配带有一个名为*attr*的属性的元素，其值末尾为*value*子字符串。 |
| [attr*=value] | 匹配带有一个名为attr的属性的元素，其值的字符串中的任何地方（子串），至少出现了一次value子字符串。 |

### 伪类选择器

用于定义元素的特殊状态，使用`:`表示

a标签的的4个伪类，必须按照特定顺序编写，否则后编写的会失效，编写顺序为`a:link`,`a:visited`,`a:hover`,`a:activte`。口诀：**l**o**v**e,**ha**te

### 伪元素选择器

用于设置元素指定部分的样式，使用`::`表示

用于创建不在文档树中的元素，并为其添加样式，默认是inline，可以通过子绝夫相来调整伪元素的位置，伪元素必须要设置content才能显示

### 其他

| 选择器类型         | 语法    | 作用范围                                | 示例      |
| :----------------- | :------ | :-------------------------------------- | :-------- |
| **相邻兄弟选择器** | `A + B` | 选择紧接在 `A` 后面的第一个同级元素 `B` | `div + p` |
| **子选择器**       | `A > B` | 选择 `A` 的直接子元素 `B`               | `div > p` |
| **后代选择器**     | `A B`   | 选择 `A` 的所有后代元素 `B`             | `div p`   |

## 选择器的优先级

| **选择器**     | **格式**      | **优先级权重** |
| -------------- | ------------- | -------------- |
| id选择器       | #id           | 100            |
| 类选择器       | .classname    | 10             |
| 属性选择器     | a[ref=“eee”]  | 10             |
| 伪类选择器     | li:last-child | 10             |
| 标签选择器     | div           | 1              |
| 伪元素选择器   | li:after      | 1              |
| 相邻兄弟选择器 | h1+p          | 0              |
| 子选择器       | ul>li         | 0              |
| 后代选择器     | li a          | 0              |
| 通配符选择器   | *             | 0              |

内联样式的优先级权重为1000，`!important`的优先级为最高

**优先级权重相同的情况下，后出现的样式生效**

继承得到的优先级最低(比0还低)

样式表的来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式

## 可继承属性和不可继承属性

不可继承:

- display
- 文本属性
- 盒子模型属性(margin,border...)
- 背景属性
- 定位属性

可继承:

- 字体属性
- 文本属性
- 光标属性
- 列表布局属性(list-style)

## display的属性有哪些

| **属性值**   | **作用**                                                   |
| ------------ | ---------------------------------------------------------- |
| none         | 元素不显示，并且会从文档流中移除。                         |
| block        | 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。       |
| inline       | 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 |
| inline-block | 默认宽度为内容宽度，可以设置宽高，同行显示。               |
| list-item    | 像块类型元素一样显示，并添加样式列表标记。                 |
| table        | 此元素会作为块级表格来显示。                               |
| inherit      | 规定应该从父元素继承display属性的值。                      |

（1）**block：**会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；

（2）**inline：**元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin，高、宽默认为内容高宽；

（3）**inline-block：**将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。

## 隐藏元素的方法

- `display:none`:不会被渲染进dom

- `visibility: hidden`:会被渲染，但不会响应事件

- `opacity:0`:会被渲染，且会响应事件

- `position: absolute`：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。

- `z-index: 负值`：来使其他元素遮盖住该元素，以此来实现隐藏。

- `transform: scale(0,0)`:将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件

  只有opacity和position两种情况会响应事件

## 盒子模型

标准盒子模型，height和width对应content

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_746%2Climit_0#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=746&size=0&status=done&style=none&width=600?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

IE盒子模型，height和width对应content+padding+border

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_791%2Climit_0#align=left&display=inline&height=368&margin=%5Bobject%20Object%5D&originHeight=462&originWidth=791&size=0&status=done&style=none&width=630?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

通过修改`box-sizing`属性来改变元素盒模型，content-box为标准盒子，border-box为IE盒子

## 为什么有时候用**translate**来改变位置而不是定位

因为translate属于transform，而改变transform或opacity并不会触发浏览器的重绘或重新布局，改变定位会引发重新布局

1. **不影响布局信息**：
   `transform` 属性（如 `translate`、`rotate`、`scale`）**不会改变元素的布局信息**，它只是在元素渲染后对其进行视觉变换，因此**不会触发重排**。
2. **直接作用于合成层**：
   现代浏览器会为应用了 `transform` 的元素创建一个**独立的合成层**，变换操作直接在合成层完成，跳过布局和绘制阶段，极大提升性能。

## 重绘和重排

重绘：某些元素的外观被改变所触发的浏览器行为（重新计算节点在屏幕中的绝对位置并渲染的过程）； 例如：修改元素的填充颜色，会触发重绘

重排（回流）：重新生成布局，重新排列元素（重新计算各节点和css具体的大小和位置：渲染树需要重新计算所有受影响的节点**）；例如：改元素的宽高，会触发重排

重排的发生情况

- 改变布局
- 改变几何属性，如宽高，边框宽度，字体大小等
- 获取计算值，如offsetTop，scrollTop。因为计算的即时性



如何优化

统一修改css样式

将修改的dom元素脱离文档流，修改后再返回文档流

将修改的dom元素离线（display改为none）

## 可置换元素

就是会被替换的元素，如**img**,video,iframe。css渲染模型不考虑对此内容的渲染(内容一般都是其他负责，如从网络上下载)，只会影响元素的位置。

## CSSSprites

精灵图，将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。

优点是可以减少网页请求

缺点是更新麻烦

## margin和padding的使用场景

margin在border外填充，无背景颜色

padding在border内填充，背景颜色跟随块的背景颜色(`background-color`)

## line-height

- line-height是一行文本的高度，从下一行基线到上一行基线的高度
- 如果标签没有定义height，则标签高度为line-height。同理，撑开标签的高度也是line-height，而不是文本
- 设置line-height = height可以实现单行文本的垂直居中
- line-height可以使用px固定，也可以使用em参考父元素font-size计算行高。如果设置纯数字，则是比例，例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px。

## 预处理器和后处理器

预处理器：less，sass，用在写css的时候

后处理器：postCss，在完成的css中添加浏览器私有前缀等，实现兼容

## 单行、多行文本溢出

```
// 单行文本
overflow: hidden;            // 溢出隐藏
text-overflow: ellipsis;      // 溢出用省略号显示
white-space: nowrap;         // 规定段落中的文本不进行换行

// 多行文本
overflow: hidden;            // 溢出隐藏
text-overflow: ellipsis;     // 溢出用省略号显示
display:-webkit-box;         // 作为弹性伸缩盒子模型显示。
-webkit-box-orient:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列
-webkit-line-clamp:3;        // 显示的行数
```

## 媒体查询

`@media(...)`,只有当符合要求的时候才会响应样式，用于适配不同尺寸的媒体设备

```js
<!-- link元素中的CSS媒体查询 --> 
<link rel="stylesheet" media="(max-width: 800px)" href="example.css" /> 
<!-- 样式表中的CSS媒体查询 --> 
<style> 
@media (max-width: 600px) { 
  .facet_sidebar { 
    display: none; 
  } 
}
</style>
```

## 如何判断元素是否到达可视区域

- 内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`

![](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_53%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_1500%2Climit_0)

## z-index什么情况下会失效

z-index反应了元素的层级，z-index越大的，层级越靠上

做了几个实验，都不会失效，float可以和z-index共存，父组件的状态也不会影响z-index

子元素的z-index受限于父元素的z-index

## 常用的CSS布局单位

像素：与设备密度有关，一般都是统一的

百分比：子元素的百分比相对于父元素，可以自适应变化

em和rem：

- 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。
-  rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。**作用**：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。

vw/vh：与百分比类似，但百分比更细化，有的属性甚至可以百分比自身(border-radius、translate)

- vw：相对于视窗的宽度，视窗宽度是100vw；
- vh：相对于视窗的高度，视窗高度是100vh；
- vmin：vw和vh中的较小值；vmax：vw和vh中的较大值；

## 什么是BFC

BFC（Block Formatting Context）就是给盒子加了一个属性，使得盒子变成了独立渲染的一部分，内部不受外界影响。

### 如何成为BFC

- 根元素
- 设置浮动
- 绝对定位或fixed定位
- 设置display为inline-block、flex、grid、table、table-cell、table-caption、flow-root
- 设置overflow(auto,scroll,hidden)

对于如果是父元素，可以设置display:inline-block;如果是子元素，可以设置overflow:hidden

### BFC有什么用

- 相邻元素（top和dowm，left和right）的外边距（margin）会合并，合并后margin取值大者。可以给任意元素添加overflow:hidden，使其成为BFC，就可以合并边距了
- 父元素和子元素的外边距塌陷（父元素和其第一个子元素或最后一个子元素之间的垂直外边距发生合并的现象），可以给父元素设置边框或内边距解决，也可以将父元素变成BFC
- 父元素高度塌陷（子元素脱离文档流），可以为父元素开启BFC避免
- 浮动重叠（元素设置成float后脱离文档流，遮住了本来的内容），可以给被遮挡元素开启BFC

## 两栏布局的实现

一般是左边栏固定大小，右边栏自适应

1. 利用浮动，左边栏设置成浮动，宽度200px，右边栏设置margin-left:200px，宽度auto
2. 利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠
3. 利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1
4. 利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。
5. 利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，**其余方向定位为0（必须设置，否则没元素填充和其他定位，会导致宽度为0）**

## 三栏布局的实现

一般是左右两栏固定大小，中间一栏自适应

1. 利用**绝对定位**，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。

2. 父组件利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1

3. 利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式**，中间一栏必须放到最后**

4. 圣杯布局

   ![](./圣杯布局1.png)

   ![](./圣杯布局2.png)

   ![](./圣杯布局3.png)

   ![](./圣杯布局4.png)

5. 双飞翼布局

   本质与圣杯布局类似，但是非父元素padding实现，而是通过center预留margin实现

   ```html
   <div class="outer">
     <div class="wrapper">
       <div class="center">
         center
       </div>
     </div>
     <div class="left">
       left
     </div>
     <div class="right">
       right
     </div>
   </div>
   
   <style>
     .outer {
       height: 100px;
     }
   
     .left {
       float: left;
       margin-left: -100%;
       width: 100px;
       height: 100px;
       background: tomato;
     }
   
     .right {
       float: left;
       margin-left: -200px;
       width: 200px;
       height: 100px;
       background: gold;
     }
   
     .wrapper {
       float: left;
       width: 100%;
       height: 100px;
       background: lightgreen;
     }
   
     .center {
       margin-left: 100px;
       margin-right: 200px;
       height: 100px;
     }
   </style>
   ```

## 水平垂直居中的实现

1. 利用子绝父相，将子元素通过`top:50%`和`left:50%`定位到页面中心，再通过`transform:translate(-50%,-50%)`使其变成垂直水平居中
2. 如果父元素有宽高，可以先通过子绝父相定位，将top,bottom,left,right设置为0，margin设置成auto实现在父元素中水平垂直居中
3. 若自身宽高已知，可以先通过子绝父相完成定位，再通过负margin值来调整水平垂直居中
4. 通过flex布局，修改`justify-content:center;align-items:center;`

## flex布局详解

采用flex布局的元素会变成flex容器，所有子元素自动成为容器成员，称为项目(item)。容器默认存在两根轴，水平的主轴和垂直的交叉轴，项目默认为水平主轴

容器的几个属性：

1. flex-direction:决定主轴的方向。值为row(水平)，row-reverse(反向水平)，column(垂直)，column-reverse(反向垂直)，initial(默认)，inherit(继承父属性)
2. flex-wrap:如何换行。值为wrap(换行)，wrap-reverse(反向换行，123换行后变321)，nowrap(不换行)
3. justify-content:主轴的对齐方式。值为start(起点对齐)，end(终点对齐)，center(居中对齐)，space-between(均匀分布，两侧对齐)，space-around(均匀分布，两侧预留中间间隔的一半)，space-evenly(均匀分布，两侧预留=中间间隔)
4. align-items:侧轴的对齐方式。值为start，center，end，stretch(如果没有设置宽/高，则会拉伸铺满)
5. align-content:多轴线的对齐方式，单轴线下无效

项目的几个属性：

1. order:排列顺序，值越小越靠前
2. flex-grow:项目的放大比例（也可以理解为剩余空间的分配权重）。默认为0，即不放大。若所有伸缩项目的 flex-grow 值都为 1 ，则：它们将等分剩余空间（如果有空间的话）。若三个伸缩项目的 flex-grow 值分别为： 1 、 2 、 3 ，则：分别瓜分到： 1/6 、 2/6 、3/6 的**剩余空间**。如果flew-grow的和小于1，如0.1,0.2,0.2，则新剩余空间为源剩余空间的1/2，再进行分配
3. flex-shrink:项目的缩小比例，默认为1。具体的计算方法为：若三个伸缩项目的 flex-flex-shrink 值分别为： 1 、 2 、 3，其宽度分别为200px,300px,400px，容器的宽度为500px，此时需要收缩900-500=400px。先用权重乘以其宽度求和得200+600+1200=2000px，计算收缩的比例分别为200/2000,600/2000,1200/2000，将比例与收缩的宽度相乘即可得到项目的收缩宽度
4. flex-basis:即项目的基本大小，宽度的优先级为max-width/min-width > flex-basis > width > box
5. align-self:单独项目的对齐方式，会覆盖align-items，值与align-items一致，只不过是调整项目自身，对齐对象为当前flex行的其他元素

flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。flex:1 表示 flex: 1 1 0%

## 响应式设计的概念和基本原理

响应式网站设计（Responsive Web design）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。

关于原理： 基本原理是通过媒体查询`（@media）`查询检测不同的设备屏幕尺寸做处理。

关于兼容： 页面头部必须有meta声明的`viewport`。

## 什么是清除浮动

清除浮动是当父元素没有指定高度的时候，子元素设置float脱离文档流后，父元素高度塌陷。

解决的方法有：

1. 将父元素变成BFC，使其内部解决浮动问题。可以将display设置成flex，grid，flow-root（设置成table或inline-block会导致宽度也自适应，使其完全包住子元素，这是table和inline-block的特性导致的），也可以设置overflow:hidden，但有可能屏蔽了溢出的正常内容

2. 通过在最后一个浮动标签后新添加一个标签，为标签设置`clear:both`

3. 在父元素中使用clearfix，本质上和第二条类似

   ```html
   .clearfix::after{
     display: block;  //添加一个块级元素
     content: ' ';    //避免不显示，设置空文本
     clear: both;     //清除浮动
   }
   ```

## 元素的层叠顺序

从最低层开始分别是：

（1）背景和边框：建立当前层叠上下文元素的背景和边框。

（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。

（3）块级盒：文档流内非行内级非定位后代元素。

（4）浮动盒：非定位浮动元素。

（5）行内盒：文档流内行内级非定位后代元素。

（6）z-index:auto：层叠级数为auto的**定位**元素(默认为auto）。

（7）z-index:0：层叠级数为0的定位元素。

（8）正z-index：z-index属性值为正的定位元素。

## absolute和fixed的共同点和不同点

共同点：使元素脱离普通文档流，不再占据文档物理空间，同时会覆盖非定位文档元素

不同点：两者的父元素都是包含块，不过规则不同，首先，transform属性非none的可以成为absolute和fixed的包含块（两者都可基于此定位），其次，**定位元素**（position非none）也可以称为absolute的包含块。

## transform详解（待更新）

 ## sticky 定位

粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。一般情况下，它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

## 如何使用CSS编写三角形

本质上border是从四个角开始的

![](./css三角.png)



```css
.container {
	width: 0px;  // !!!保证容器只有边框，没有实际内容，如果有实际内容，则会将三角形显示成矩形
	height: 0px; // !!!同理
	border: 100px solid transparent;  // 将其他边框忽略，100px表示的是边框长度(底边/2)，实际上是一个200x200的矩形
	border-left: red 100px solid;  // 将靠左的三角形显示出来(顶角朝右)，此处的100px是水平长度
}

// 也可以只说明两个元素，这样的话，矩形的组成将不会是四个三角形拼凑，而是只有两个三角形
.container {
	width: 0px;  
	height: 0px; 
	border-top: 100px solid transparent;  
	border-left: 100px solid red;  // 这样会显示一个90度角在左下方的三角形
}
```

## 如何用CSS实现扇形

```
// 方法同三角形，只不过把扇形圆弧边所在的方向设置radius
.container{
    width: 0;
    height: 0;
    border-radius:100px;
    border:100px solid transparent;
    border-left: 100px solid red;  // 尖口朝右的扇形
}
```

## 如何用CSS实现圆形/半圆

圆形

````css
.container {
  background-color: red;
  height: 100px;
  width: 100px;
  border-radius: 50%; // 100%也可以
}
````

半圆

```css
.container {
  background-color: red;
  width: 200px;
  height: 100px;  // 高度是宽度一般
  border-radius: 0px 0px 200px 200px; // 200px对齐宽度，四个值分别代表左上，右上，右下，左下
}
```

## 如何使用CSS实现一个宽高自适应的正方形

1.使用vw，vh实现

2.利用元素的margin/padding百分比是相对父元素width的性质来实现

```
.square {
  width: 20%;  // 父元素宽度的20%
  height: 0;   // 高度为0，纯靠padding撑开
  padding-top: 20%;  // padding和margin百分比相对于父元素的宽度实现
  background: orange;
}
```

3.通过伪元素实现

```
.square {
  width: 30%;  // 可以发现，square元素没有高度，高度纯靠伪元素的margin/padding-top撑开
  overflow: hidden;
  background: yellow;
}
.square::after {
  content: '';
  display: block;  // 必须是block或是inline-block才能有margin和padding
  margin-top: 100%; // 伪元素的百分比基于square的宽度
}
```

## 实现一条宽度0.5px的线

使用transform:scale(1,0.5)

# JavaScript

## JS的数据类型有哪些，区别是什么

八大数据类型:Undefined,Null,Boolean,Number,String,Object,Symbol,BigInt

Symbol和BigInt是ES6引入的新类型，Symbol代表创建后独一无二的数据类型，BigInt用来表示Number无法精确表示的范围

栈->存储原始数据类型(Undefined,Null,Boolean,Number,String,Symbol,BigInt)

堆->存储引用数据类型(Object,Array,Function)

两种类型的区别是：

- 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。**堆是一个带有优先级的队列。**

通过Symbol.for()可以获得对应字符串的唯一Symbol，该方法在同一个环境下获得值均是相同的

使用Symbol.keyFor(symbol)可以获得symbol对应的字符串

## 如何检测数据类型

```javascript
// 1.typeof
console.log(typeof 2);  // number
// 2.instanceof 只能用于判断引用类型数据
console.log([] instanceof Array) // true
console.log({} instanceof Object) // true
const arrowFunc = () => console.log();
console.log(arrowFunc instanceof Function); // true
// 3.constructor 一般用于查看对象上的构造函数。如果原型链prototype的指向被修改，则constructor也会指向新的构造函数
console.log((2).constructor) // ƒ Number() { [native code] }
console.log((2).constructor.name) // Number 可用于类型检查
// 4.对象上的原型方法Object.prototype.toString.call(),注意这里的tostring是Object身上的，而不是普通obj上的，普通obj的tostring方法会被重写
console.log(Object.prototype.toString.call(2)) // '[object Number]'
```

## 如何检测数组类型

```js
obj = []
// 1.Object.prototype.toString.call(obj).slice(8.-1),slice用于裁切掉[object ]
console.log(Object.prototype.toString.call(obj).slice(8,-1)=='Array') //true

// 2.原型链判断
obj.__proto__ === Array.prototype;

// 3.ES6新增的isArray方法
Array.isArray(obj);

// 4.instanceof
obj instanceof Array;

// 5.通过Array.prototype.isPrototypeOf()
Array.prototype.isPrototypeOf(obj);
```

## undefined 和 null的区别

undefined出现在，未声明变量，声明但未定义变量，是一种系统默认返回的值，一般表示这里应该有值，但目前没有。

null一般需要主动用于给对象赋初始值，用来表示这里不应该有值，为空对象。typeof null的返回值为Object

## isNaN和Number.isNaN的区别

isNaN函数执行时，会先将参数进行类型转换，如果可以进行类型转换，则返回false，不可以则返回true

Number.isNaN，不会进行类型转换，而是直接判断，只有传入的为NaN才会返回true，判断上要求更加严格

```
isNaN("666")  // false
isNam("haha")  // true
Number.isNaN("6")  // false
Number.isNaN(NaN)  // true
```

## ==、===和Object.is(A,B)的区别

== 会进行类型的强制转换

=== 不会进行类型的强制转换，但 +0=== -0 返回true，NaN === NaN返回false

```
// Object.is本质上和===一样，对于部分操作返回值不同
Object.is(+0,-0) // false
Object.is(+0,0)  // true
Object.is(-0,0)  // false
Object.is(NaN,NaN)  // true
```

## 什么是包装类型

在string、number和boolean类型值上调用方法时，会将值转成对应类型的对象，这种包装时临时的，调用结束后就会销毁实例，恢复原来的类型。

```
// 调用Boolean对象的注意点
var bool = new Boolean(false);  // bool为对象
if (bool) { // 参数为对象，任何对象都会返回true
    console.log('run?'); // 会进到 if 条件里面吗？
}
```

## + 操作符何时被用于字符串的拼接

\+ 操作符其中的一个操作数是字符串的时候（或者可以隐式转换成字符串），则执行拼接，否则执行加法。除了 \+ 操作符的其他运算符都是进行数字操作

## 扩展运算符和Object.assign的拷贝行为

```
// 扩展运算符...
let a = {
  info:{
    name: 'worker',
    age: 18
  },
  gender:'male'
}
let b = {...a}
b.gender = "female"
b.info.age = 20
console.log(a) // {info:{name:'workder',age:20},gender:'male'}

// Object.assign(target,source)
let a = {
  info:{
    name: 'worker',
    age: 18
  },
  gender:'male'
}
let b = Object.assign({},a)
b.gender = "female"
b.info.age = 20
console.log(a) // {info:{name:'workder',age:20},gender:'male'}
```

两者对于对象的引用数据类型是浅拷贝，对于基本数据类型是深拷贝

## 如何判断空对象

**`Object.keys(obj).length === 0`**

## for in 和for of

for in 一般用于获取对象的属性，也可以获取数组的索引（但会包括数组的其他属性（如果声明了的话））

for of 一般用于获取对象和数组的值

遍历数组一般使用for和forEach(数组自身方法)方法

arr.forEach((value,index,array)=>{}),array是调用forEach的数组。推荐在回调函数中使用array

四者性能for>for of>forEach>for in

## 基本类型方法

### Number

```javascript
// 静态方法，通过Number.调用
Number.isNaN(value) // 判断一个值是否为NaN，与全局的isNa方法相比，该方法直接和NaN进行对比，不会进行类型转换
Number.isFinite(value)// 判断值是Infinity，-Infinity或NaN
Number.isInteger(value) // 判断值是否为整数
Number.parseFloat(value) // 将字符串转换成浮点数
Number.parseInt(value) // 将字符串转换成整数

// 实例方法，运用在具体的变量上
const num = 3.14;
console.log(num.toFixed(3)); // "3.142"，固定小数位数
console.log(num.toExponential(1)); // "3.1e+0"，转科学计数法
console.log(num.toString()); // "3.14159" 转字符串
```

### String

```javascript
const str = "Hello, world!";

// 字符串查找与匹配
console.log(str.includes("world")); // 检查字符串是否包含子串"world"，返回true
console.log(str.indexOf("o"));      // 返回子串"o"首次出现的位置，返回4

// 字符串截取与替换
console.log(str.slice(7, 12));      // 提取索引7到12(不包含)的子串，返回"world",不修改原字符串
console.log(str.replace("world", "universe")); // 替换首个"world"为"universe"，返回"Hello, universe!"

// 字符串格式化与转换
console.log(str.toUpperCase());     // 将字符串转为大写，返回"HELLO, WORLD!"
console.log("   Trim me   ".trim()); // 移除字符串两端空格，返回"Trim me"

// 字符串分割与连接
console.log(str.split(", "));       // 按", "分割字符串，返回数组["Hello", "world!"]
console.log(["a", "b", "c"].join("-")); // 用"-"连接数组元素，返回"a-b-c"
```

### Array

```javascript
const arr = [1,2,3]

const newArr = Array.from(arr) // 可以将arr实现浅拷贝（arr中的引用对象依旧为原来的引用对象），或者将一个类数组或可迭代对象(Map,Set)转换成数组
console.log(Array.from(arr, x => x * 2)); // [2, 4, 6] // 也可以添加操作
// 其他浅拷贝数组的方法
const shallowCopy = [...originalArray]; // 解构
const shallowCopy = originalArray.slice(); // 调用数组的slice方法
const shallowCopy = [].concat(...originalArray); // 使用concat拼接

const arr = Array.of(1,2,3) // [1,2,3] // 将所有传入的参数形成一个数组
arr.keys() // 返回索引
arr.values()  // 返回值
arr.entries()  // 返回索引键值
arr.fill(0, 2, 4); // 从索引2到4（不包含4),填充0，start和end为可选，默认为首尾

arr.sort((a,b)=>a-b) // 看a-b的返回值，负数为升序，正数为降序

// 数组迭代方法
// every()：对数组每一项都运行传入的函数，如果对每一项函数都返回true，则这个方法返回true。
// filter()：对数组每一项都运行传入的函数，函数返回true 的项会组成数组之后返回。
// forEach()：对数组每一项都运行传入的函数，没有返回值。
// map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
// some()：对数组每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true。
// array.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])
// acc是累计的类容，cur是当前值，index是当前索引，array是源数组。如果不提供initialValue，则首次迭代会将accumulator设为initialValue，而currentValue从第二个元素开始
```

### Map

- set() 方法可以添加键/值对；
- get() 方法可以指定某个键来返回某个 Map 对象中对应的值；
- has() 方法返回一个bool值，用来表明 Map 中是否存在指定键；
- delete() 方法用于移除 Map 对象中指定的元素；
- clear() 方法会移除 Map 对象中的所有元素；
- size 属性可以获取 Map 对象中的键/值对的数量。

#### WeakMap

键只能是对象类型，且为弱引用，可以被垃圾检测机制回收。不可枚举，不可迭代

- set() 方法可以添加键/值对；
- get() 方法可以指定某个键来返回某个 Map 对象中对应的值；
- has() 方法返回一个bool值，用来表明 Map 中是否存在指定键；
- delete() 方法用于移除 Map 对象中指定的元素；

### Object

```javascript
Object.defineProperties(对象，{key:value,key:value}) // 可以在其中配置writable，enumerable和configurable
Object.assign(obj1,obj2) // 用于合并多个对象，基本类型为浅拷贝。如果有重复的以最后一个为准
Object.create(obj,{key:value}) // 创建一个继承自obj的对象，可以使用第二个参数来为其添加属性

obj.isPrototypeOf(OBJ) // （左操作数）是否存在于另一个对象（右操作数）的原型链中
obj instanceOf func // 左操作数（对象）是否是右操作数（构造函数）的直接或间接实例
```



# ES6中的新特性

## let，const，var的区别

**（1）块级作用域：**块作用域由 `{ }`包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：

- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为全局变量

**（2）变量提升：**var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。

**（3）给全局添加属性：**浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。

**（4）重复声明：**var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。

**（5）暂时性死区：**在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**。使用var声明的变量不存在暂时性死区。

**（6）初始值设置：**在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。

**（7）指针指向：**let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。



```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 同时输出3，3，3。因为setTimeout是宏任务，js执行到这的时候，会将宏任务放入队列，然后循环三次。循环结束后再执行宏任务队列中的任务，此时var声明的变量会保留在外部的作用域中，所以最后会输出3，3，3。
  }, 100);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i); // 同时输出0，1，2。因为let是块作用域，只会在内部被使用
  }, 100);
}

// 如何异步输出？
for (let i = 0; i < 3; i++) {
  await new Promise(resolve => setTimeout(resolve, 100)); // await会等待Promise完成，setTimeout中执行resolve，使得Promise状态发生改变
  console.log(i); // 0、1、2间隔100ms依次输出
}
```



## const声明的对象是否可修改

const是指向目标地址的指针不可修改，而目标地址的内容可以修改，对于基础类型而言，无法在原有地址上修改内容，所以无法修改。对于引用类型而言，可以修改

## 箭头函数的特点

- 箭头函数没有自己this，**this在函数定义的时候就会被确定，默认为外层的this**，且永远不会改变
- 使用call(),apply(),bind()等方法无法改变箭头函数中的this指向
- 箭头函数为匿名函数，所有无法通过new来构造
- 箭头函数无法通过arguments来获取函数参数，只能通过扩展运算符来获得

ps:`arguments`还有一个属性callee，指向`arguments`对象所在函数。可以通过`arguments.callee()`来实现递归

## 模板语法与字符串处理

```js
let a = "hello";
let b = "world";
console.log(`${a + b}`);

// 字符串类型数据的自带方法
string.includes(str)   //判断是否包含str
string.startsWith(str) //判断是否以str开始
string.endWith(str)    //判断是否以str结束
string.repeat(num)     //对字符串重复num次
```

## new的实现原理

本质上可以理解成继承，步骤如下

1. 首先创建了一个新的空对象
2. 将对象的原型设置成构造函数的prototype对象
3. 让函数的this指向这个对象，然后执行构造函数的代码
4. 判断函数的返回值类型，如果是基础类型，则返回创建的对象，如果是引用类型，则返回引用的对象

```
// 以下代码解释第四点
function Test(name) {
  this.name = name
  return 1 // 返回基本类型
}
const t = new Test('xxx')
console.log(t.name) // 'xxx'，说明返回的构造了的对象

function Test(name) {
  this.name = name
  console.log(this) // Test { name: 'xxx' }
  return { age: 26 }
}
const t = new Test('xxx')
console.log(t) // { age: 26 } //说明返回的是{ age: 26 }
console.log(t.name) // 'undefined'
```

## map和object的区别

| Map                                                          | Object                                                       |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Map默认情况不包含任何键，只包含显式插入的键。                | Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。 |
| Map的键可以是任意值，包括函数、对象或任意基本类型。          | Object 的键必须是 String 或是Symbol。                        |
| Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。 | Object 的键是无序的                                          |
| Map 的键值对个数可以轻易地通过size 属性获取                  | Object 的键值对个数只能手动计算                              |
| Map 是 iterable 的，所以可以直接被迭代。                     | 迭代Object需要以某种方式获取它的键然后才能迭代。             |
| 在频繁增删键值对的场景下表现更好。                           | 在频繁添加和删除键值对的场景下未作出优化。                   |

## map和weakMap的区别

1. Map

   Map的key可以为任意类型。自身携带的操作方法如下

   size,set,get,has,delete,clear,keys,values,entries,forEach

2. weakMap

   weakMap中key值必须是对象，只有set,get,has,delete方法（因为weakMap中的key有可能随时被回收，所以不提供），weakMap中的key是弱引用对象，当该对象的引用次数归零后，垃圾回收机制会自动回收，weakMap中的该key无法再被访问

## 正则表达式（待补充）

## JSON

用于数据交换，通过JSON.stringify将js数据转换成JSON，通过JSON.parse将JSON转换成js数据

## JS中的类数组是什么

拥有length属性和若干索引属性的对象可以被称作类数组对象，类数组对象无法调用数组的方法。可以通过以下方式实现类数组到数组的转换

```
Array.prototype.slice.call(arrayLike);
Array.prototype.splice.call(arrayLike, 0); //会清空源对象
Array.prototype.concat.apply([], arrayLike);
Array.from(arrayLike); //推荐，同时适用set，map
```

## 常见的位运算符

运算符均是对二进制数值进行转换

| 运算符 | 描述 | 运算规则                                                 |
| ------ | ---- | -------------------------------------------------------- |
| `&`    | 与   | 两个位都为1时，结果才为1                                 |
| `|`    | 或   | 两个位都为0时，结果才为0                                 |
| `^`    | 异或 | 两个位相同为0，相异为1                                   |
| `~`    | 取反 | 0变1，1变0                                               |
| `<<`   | 左移 | 各二进制位全部左移若干位，高位丢弃，低位补0              |
| `>>`   | 右移 | 各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃 |

## 什么是DOM和BOM

- DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。
- BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。

## Ajax

通过JS实现异步通信，来更新网页

操作步骤：

- **创建一个 XMLHttpRequest 对象。**
- 在这个对象上**使用 open 方法创建一个 HTTP 请求**，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。
- 在发起请求前，可以为这个对象**添加一些信息和监听函数**。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。
- 当对象的属性和监听函数设置完成后，最后调**用 sent 方法来向服务器发起请求**，可以传入参数作为发送的数据体。

```
const SERVER_URL = "/server";
let xhr = new XMLHttpRequest();
// 创建 Http 请求
xhr.open("GET", url, true);
// 设置状态监听函数
xhr.onreadystatechange = function() {
  if (this.readyState !== 4) return;
  // 当请求成功时
  if (this.status === 200) {
    handle(this.response);
  } else {
    console.error(this.statusText);
  }
};
// 设置请求失败时的监听函数
xhr.onerror = function() {
  console.error(this.statusText);
};
// 设置请求头信息
xhr.responseType = "json";
xhr.setRequestHeader("Accept", "application/json");
// 发送 Http 请求
xhr.send(null);

// 使用Promise封装
function getJSON(url) {
  // 创建一个 promise 对象
  let promise = new Promise(function(resolve, reject) {
    let xhr = new XMLHttpRequest();
    // 新建一个 http 请求
    xhr.open("GET", url, true);
    // 设置状态的监听函数
    xhr.onreadystatechange = function() {
      if (this.readyState !== 4) return;
      // 当请求成功或失败时，改变 promise 的状态
      if (this.status === 200) {
        resolve(this.response); //resolve
      } else {
        reject(new Error(this.statusText)); //reject
      }
    };
    // 设置错误监听函数
    xhr.onerror = function() {
      reject(new Error(this.statusText));
    };
    // 设置响应的数据类型
    xhr.responseType = "json";
    // 设置请求头信息
    xhr.setRequestHeader("Accept", "application/json");
    // 发送 http 请求
    xhr.send(null);
  });
  return promise;
}
```

## ES6模块和CommonJS模块的区别

CommonJS是对模块的复制，且可以修改引入的对象。

ES6是对模块的深拷贝，不能改变指向的模块。

两者均可对模块内部进行修改

## for ... of ...

| 特性     | `for...of`                          | `for...in`                 |
| :------- | :---------------------------------- | :------------------------- |
| 遍历内容 | **可迭代对象**的值(或键值)          | 对象的可枚举属性           |
| 适用对象 | 数组、字符串、Map、Set 等可迭代对象 | 普通对象                   |
| 原型属性 | 不遍历原型链上的属性(效率更高)      | 会遍历原型链上的可枚举属性 |
| 顺序     | 按迭代器定义的顺序                  | 不保证顺序                 |

```
//  若要让普通对象可以使用for...of，需要给普通对象加上迭代器属性
var obj = {
    a:1,
    b:2,
    c:3
};

obj[Symbol.iterator] = function(){
	var keys = Object.keys(this);
	var count = 0;
	return {
		next(){
			if(count<keys.length){
				return {value: obj[keys[count++]],done:false}; // 迭代器语法
			}else{
				return {value:undefined,done:true};  // 迭代器语法
			}
		}
	}
};

for(var k of obj){
	console.log(k);
}
```

## ajax、fetch、axios的区别

**ajax**

- 本身是针对MVC编程，不符合前端MVVM的浪潮
- 基于原生XHR开发，XHR本身的架构不清晰

**fetch**

- ES6启用，使用了Promise对象
- 支持async/await
- fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
- 默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
- `fetch()` 接收到的 `response` 是一个 `Stream` 对象，需要将 `response` 序列化(json())才能获取到数据

**axios**的请求过程为：

1. 创建请求实例（配置url，header等）
2. 通过请求拦截器（对请求进行修改）
3. 转换请求数据（将js数据转换成JSON）
4. 发起网络请求（web端使用XMLHttpRequest，node端使用http模块），自动处理跨域
5. 通过响应拦截器（对响应进行修改）
6. 转换数据（将JSON转换成js）

## 数组的遍历方法

| **方法**                  | **是否改变原数组** | **特点**                                                     |
| ------------------------- | ------------------ | ------------------------------------------------------------ |
| forEach()                 | 否                 | 数组方法，默认不改变原数组，没有返回值，不可以链式调用       |
| map()                     | 否                 | 数组方法，不改变原数组，返回新数组，可链式调用               |
| filter()                  | 否                 | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 |
| for...of                  | 否                 | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |
| every() 和 some()         | 否                 | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |
| find() 和 findIndex()     | 否                 | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |
| reduce() 和 reduceRight() | 否                 | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 |

## 原型和原型链

当我声明一个普通函数（构造函数）的时候，js会自动生成一个对象，内容包含一个constructor指向普通函数和一个\__proto\_\_ 指向Object.prototype(最终原型) 	

![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1615475711487-c474af95-b5e0-4778-a90b-9484208d724d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_5b6u5L-h5YWs5LyX5Y-377ya5YmN56uv5YWF55S15a6d%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_618%2Climit_0)

个人理解：首先所有引用类型都有\_\_proto\_\_，函数可以通过\_\_proto\_\_找到Function.prototype，从而使用通用的方法(bind,call),通过prototype找到与自己对应的原型对象，原型对象通过\__proto\_\_属性找到自己原型链中的上一层，通过constructor找到对应的构造函数。逐层搜索原型链最终回到Object.prototype。

ES6后不推荐使用_\_proto__来访问原型对象，建议使用Object.getPrototypeOf(obj)

原型链的终点是Object.prototype.\_\_proto\_\_，而Object.prototype._\_proto\_\_===null，所以也可以说原型链的终点就是null

对象可以通过从原型链中层层向上寻找可使用的方法，可以通过hasOwnProperty()来判断是否属于原型链的属性

## 什么是闭包

闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包最常见的方法就是在一个函数内创建另一个函数，这个创建的函数可以访问到当前函数的局部变量。一般出现在嵌套函数中（外层函数的变量被内层函数使用，导致外层函数执行完毕时，声明的变量因为内层函数的引用而被保留）

闭包的常用作用：

- 可以在函数外部访问到函数内部的局部变量
- 会保留闭包内所用的对象的引用，从而不被垃圾回收机制回收

如何解决：

用完外层变量后，将其设为null，解除引用



## 作用域、作用域链

（1）全局作用域

- 最外层函数和最外层函数外面定义的变量拥有全局作用域
- 所有未定义直接赋值的变量自动声明为全局作用域
- 所有window对象的属性拥有全局作用域
- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

（2）函数作用域

- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
- 作用域是分层的，内层作用域可以访问外层作用域，反之不行

（3）块级作用域

- 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由`{ }`包裹的代码片段）
- let和const声明的变量不会有变量提升，也不可以重复声明
- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

（4）作用域链

​	在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

## 执行上下文

**（1）全局执行上下文**

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

**（2）函数执行上下文**

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

**（3）**`eval`**函数执行上下文**

执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。

当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。



在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this（绑定this）和arguments

## apply/call/bind

三者都是为了改变函数执行的上下文（改变this），如果传入underfined或null则绑定的是全局的window对象

```js
// apply将接受两个参数，第一个参数是this的指向，第二个参数是函数参数，一般是数组或者类数组的形式，该方法只能临时改变this
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}
fn.apply(obj,[1,2]); // ->Object,Array
fn(1,2) // ->Window,Array

// call本质和apply类似，不过接受多个参数，第一个参数是this指向，后续参数均是函数参数
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}
fn.call(obj,1,2); // ->Object,Array
fn(1,2) // ->Window,Array

// bind与前两者不同，不是立即执行，而是需要先通过bind绑定对象，返回后的函数就直接改变了绑定的对象，再通过调用返回后的函数实现
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}

const bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind函数不会立即执行，需要手动执行
bindFn(1,2) // ->Object,Array
fn(1,2) // ->Window,Array
```

## 如何实现异步编程

在JS中实现异步编程的方法有如下几种：

- 回调函数嵌套回调函数，容易形成回调地狱
- Promise，也可以嵌套Promise，但会造成多个then调用
- generator
- async/await，该机制相当于Promise和generator的结合，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行，如果是普通表达式，则会直接执行。对于async函数而言，返回的也是一个Promise对象，如果async函数内有返回值，该值会作为resolve的值。async/await可以解决频繁调用.then的情况

```js
// 原函数
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}
doIt();

// async/await版本,将原先的链式.then拆分成多个await执行即可，每个await都会阻塞，和以上版本的性质类似
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}
doIt();
```

```js
// 在async/await中捕获异常
async function fn(){
    try{
        let a = await Promise.reject('error')
    }catch(error){
        console.log(error)
    }
}
```

## Promise

![](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png)

构建promise的时候，其中的代码会立即执行，.then()后的是微任务

Promise实例存在三种状态：Pending(进行中)，Resolved(已完成)，Rejected(已拒绝)

存在两种过程pending->fulfilled:Resolved和pending->rejected:Rejected，一旦进入任一状态后就无法再更改

可以直接通过Promise.resolve/reject()来创建一个对象，对象创建后可以直接使用.then()

promise.then(成功的函数，失败的函数)，.then执行后返回的也是Promise对象，所以可以直接.then链式调用

.then()中比如传入函数，如果传入的非函数，则会用上一个Promise的结果进行透传

```js
Promise.resolve(1) // Promise的值为1
  .then(2)  // 非函数，透传，值为1
  .then(Promise.resolve(3)) // 非函数，透传，值为1
  .then(console.log) // 输出1
```

也可以不写失败的函数，改写成promise.then(成功的函数).catch(失败的函数)

.catch只能捕获之前Promise中throw的error，如果是return error，则会包装成return resolve(error)

.finally方法不接受任何参数（内部不关心promise的状态，传入值都为undefined），也不会传递任何值（会将前面Promise的值透传下去）

Promise.all()方法可以完成并行任务，它接收一个数组，数组的每一项都是一个`promise`对象。当数组中所有的`promise`的状态都达到`resolved`的时候，`all`方法的状态就会变成`resolved`，并返回一个包含所有resolve结果的数组，如果有一个状态变成了`rejected`，那么`all`方法的状态就会变成`rejected`,且会立刻终止

```js
// Promise手写
function myPromiseAll(promiseArray) {
    return new Promise((resolve,reject)=>{  // 返回一个Promise
        if(!Array.isArray(promiseArray)){
            return reject(new TypeError('argument must be an array'))
        }
        const length = promiseArray.length  // 获取数组长度
        const result = new Array(length)    // 创建一个和promiseArray长度相同的数组,用于存储结果
        if(length === 0){
            return resolve(result) 
        }
        let count = 0
        promiseArray.forEach((promise,index)=>{
            Promise.resolve(promise).then(res=>{
                count++
                result[index] = res
                if(count === length){
                    resolve(result)
                }
            }).catch(err=>{
                reject(err)
            })
        })

    })
}
```

Promise.race()方法与all类似，接受的参数是一个每项都是`promise`的数组，但是与`all`不同的是，当最先执行完的事件执行完之后，就直接返回该`promise`对象的值。如果第一个`promise`对象状态变成`resolved`，那自身的状态变成了`resolved`；反之第一个`promise`变成`rejected`，那自身状态就会变成`rejected`。

```js
// 可以在数组中添加一个计时器函数，当超出这个时间后，就不执行原先的命令	
Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})
```

```js
// 手写Promise.race()
function myPromiseRace(promiseArray) {
    return new Promise((resolve, reject) => {  // 返回一个Promise
        const length = promiseArray.length
        if (!Array.isArray(promiseArray)) {
            return reject(new TypeError('argument must be an array'))
        }
        if (length === 0) {
            return resolve([])
        }
        // Promise.resolve会将每一个值包装成Promise，并放入微任务序列，等到forEach结束后，再并行执行微任务序列
        promiseArray.forEach((promise, index) => {
            Promise.resolve(promise).then(res => {
                resolve(res)
            }).catch(err => {
                reject(err)
            })
        })

    })
}
```

Promise.allSettled同时执行多个异步操作，并在所有操作都完成后（无论成功还是失败）获取每个操作的结果。与 Promise.all 不同，allSettled 不会因某个 Promise 失败而提前终止，而是始终等待所有 Promise 完成。

```js
// 手写Promise.allSettled
function myPromiseAllSettled(promiseArray) {
    return new Promise((resolve, reject) => {  // 返回一个Promise
        if (!Array.isArray(promiseArray)) {
            return reject(new TypeError('argument must be an array'))
        }
        const length = promiseArray.length  // 获取数组长度
        const results = new Array(length)
        let completedCount = 0  // 计数器，记录完成的Promise数量
        if (length === 0) {
            return resolve(results)
        }
        promiseArray.forEach((promise, index) => {
            // 将每个元素包装为 Promise（处理非 Promise 值）
            Promise.resolve(promise)
                .then(value => {
                    // 成功时记录结果
                    results[index] = {
                        status: 'fulfilled',
                        value
                    };
                })
                .catch(reason => {
                    // 失败时记录结果
                    results[index] = {
                        status: 'rejected',
                        reason
                    };
                })
                .finally(() => {
                    // 无论成功或失败，计数加1
                    completedCount++;

                    // 所有 Promise 都已完成（无论状态如何）
                    if (completedCount === promiseArray.length) {
                        resolve(results);
                    }
                });
        });

    })
}
```

Promise.finally()是最后执行的方法，不管Promise的状态是fulfilled还是rejected都会执行

## 垃圾回收机制

垃圾回收机制只会回收堆的内存（用于存储对象，数组，函数）

垃圾回收算法：

- 标记清除。首先回收机制会遍历堆内存上的所有对象，并给这些对象打上标记。在代码执行完成后，对所使用过的对象取消标记，最后删除那些还带有标记的对象
  - 优点：简单
  - 缺点：会产生碎片
- 标记整理。标记过程类似，只是在清除过程后，算法会将活着的对象往内存的一端进行移动，最后清理掉另一端的内存
- 引用计数。当变量声明并赋值后，引用值为1。当该变量被赋给另一个值后，引用值加一，相反，解除引用时，引用值减一。当引用值为0时，将其回收

V8引擎对于内存区的优化。

首先将内存区划分成新生代区和老生代区，一般老生代区的容量大于新生代区。将新生代区一分为二，划分成使用区和空闲区。新生代区的回收机制如下：

当使用区的内存即将满的时候，将使用区的内容全部移动到空闲区，移动过程中进行引用检查和排序，随后在空闲区内执行垃圾回收，回收后，空闲区会变为使用区，原先的使用区则变成空闲区。在经历两次空闲交换后仍存活的对象，就会移动到老生代区。老生代区采用的是标记整理机制。

## async/await

ES8新增

使用async包装的函数需要返回Promise对象。如果返回的值非Promise对象，会使用Promise.resolve()包裹。如果函数内部throw error，则会返回Promise.reject(error)。

await 关键字期待（但实际上并不要求）一个实现 thenable 接口的对象，但常规的值也可以。如果是实现 thenable 接口的对象，则这个对象可以由 await 来“解包”。如果不是，则这个值就被当作已经解决的期约。

代码输出题中，将await后的函数看成Promise，后续的代码看成.then(即微任务序列)。如果await 后的函数reject或抛出错误，则终止后续代码运行

## Reflect和Proxy

Proxy为代理，可以为对象设置代理对象并设置拦截器，拦截器为一个对象，属性为拦截方法

```
// 设置拦截器
const handle = {
  	get(target, prop) {
        console.log(`Getting property "${prop}"`);
        return Reflect.get(prop); // 使用反射获取值，避免无限拦截循环
  }
}
const target = {
	id:1
}
const targetProxy = new Proxy(target,handle);
```

Reflect为配合Proxy的元编程类型，不会触发任何拦截器，可以替代对象上的一些方法。会根据操作的成功与否返回布尔值。

## 尾调用优化

指在函数return的时候，执行另一个函数并返回

```js
function outerFunction() {
	return innerFunction(); // 尾调用
}
```

在ES6**优化前**，执行这个例子会在内存中发生如下的操作：

1. 执行到outerFunction 函数体，第一个栈帧被推到栈上。
2. 执行outerFunction 函数体，到return 语句。计算返回值必须先计算innerFunction。
3. 执行到innerFunction 函数体，第二个栈帧被推到栈上。
4. 执行innerFunction 函数体，计算其返回值。
5. 将返回值传回outerFunction，然后outerFunction 再返回值。
6. 将栈帧弹出栈外。

再ES6**优化后**，执行这个例子会在内存中发生如下的操作：

1. 执行到outerFunction 函数体，第一个栈帧被推到栈上。
2. 执行outerFunction 函数体，到达return 语句。为求值返回语句，必须先求值innerFunction。
3. 引擎发现把第一个栈帧弹出栈外也没问题，因为innerFunction 的返回值也是outerFunction的返回值。
4. 弹出outerFunction 的栈帧。
5. 执行到innerFunction 函数体，栈帧被推到栈上。
6. 执行innerFunction 函数体，计算其返回值。
7. 将innerFunction 的栈帧弹出栈外。

第一种情况下，每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多少次嵌套函数，都只有一个栈帧。这就是ES6尾调用优化的关键：如果函数的逻辑允许基于尾调用将其销毁，则引擎就会那么做。

# Vue

## computed和watch区别

**对于Computed：**

- 它支持缓存，只有依赖的数据发生了变化，才会重新计算
- 不支持异步，当Computed中有异步操作时，无法监听数据的变化
- computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。
- 如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed
- 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。

**对于Watch：**

- 它不支持缓存，数据变化时，它就会触发相应的操作
- 支持异步监听
- 监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值
- 当一个属性发生变化时，就需要执行相应的操作
- 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：

- - immediate：组件加载立即触发回调函数
  - deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。

当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。

**总结：**

- computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 
- watch 侦听器 : 更多的是**观察**的作用，**无缓存性**，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。 

## v-if和v-show的区别

- **手段**：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；
- **编译过程**：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；
- **编译条件**：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；
- **性能消耗**：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；
- **使用场景**：v-if适合运营条件不大可能改变；v-show适合频繁切换。

## v-model 是如何实现的，语法糖实际是什么

本质上是一个两个功能的语法糖

```js
:modelValue="foo"
@update:modelValue="$event => (foo = $event)"
```

多用在表单中，如果用在父子组件中，需要在子组件中使用props和emit来触发父组件的修改

```js
const props = defineProps(['modelValue'])
const emit = defineEmits(['update:modelValue'])
```

vue3.4中添加了一个新的语法糖，defineModel()可用在子组件中，替代上面的两个操作

```js
// 第一个参数对应父组件中v-model:title,第二个可以进行配置，如required,default等
const title = defineModel('title', { required: true })
```

## keep-alive

`<keep-alive>`标签用于将标签内的组件缓存起来

缓存对应的周期是onActivated()和onDeactivated() ，但会少beforeDestroy 和 destroyed 两个钩子，因为组件不会被销毁

keep-alive有以下三个属性：

- include 字符串（逗号分割），只有名称匹配的组件会被匹配；
- exclude 字符串（逗号分割），任何名称匹配的组件都不会被缓存；
- max 数字，最多可以缓存多少组件实例，采用最近最久未使用LRU算法。

## nextTick()

在以下情况下，会用到nextTick：

- 在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在`nextTick()`的回调函数中。
- 在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在`nextTick()`的回调函数中。因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在`nextTick()`的回调函数中。

$nextTick使用事件循环的原理来实现在视图渲染完成后执行所有回调函数的功能。

而且，为在视图渲染完成后尽快执行回调，$nextTick根据浏览器的兼容性来渲染执行异步任务的方法，先检查是否能使用微任务（Promise, MutationObserver），不行的话则使用宏任务（setImmediate, setTimeout）。

## vue中template到render的过程

首先通过parse方法将template转换成ast（抽象语法树）

深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根（即不依赖响应式数据）。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。

最后将ast转换成js代码（先转成render函数的参数，再使用render函数进行渲染）

## vue中的单项数据流

子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的**单向数据流**。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。

Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。

**只能通过** `**$emit**` **派发一个自定义事件，父组件接收到后，由父组件修改。**

## assets和static的区别

**相同点：** `assets` 和 `static` 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点

**不相同点：**`assets` 中存放的静态资源文件在项目打包时，也就是运行 `npm run build` 时会将 `assets` 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 `static` 文件中跟着 `index.html` 一同上传至服务器。`static` 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 `static` 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 `assets` 中打包后的文件提交较大点。在服务器中就会占据更大的空间。

**建议：** 将项目中 `template`需要的样式文件js文件等都可以放置在 `assets` 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如`iconfoont.css` 等文件可以放置在 `static` 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。

## vue中常用的性能优化

1.路由懒加载。import是异步加载，然后打包工具会分辨import，使其成为独立的包。

```js
// 使用ES6中的动态导入
const Home = () => import('./views/Home.vue')
const About = () => import('./views/About.vue')

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home
  },
  {
    path: '/about',
    name: 'About',
    component: About
  }
]

// 直接使用
const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('./views/Home.vue')
  },
  {
    path: '/about',
    name: 'About',
    component: () => import('./views/About.vue')
  }
]
```

2. 图片懒加载

可以使用库vue-lazyload

原理是监控图片是否出现在可视区域内，如果没有出现，则使用一个默认图片进行占位，如果出现则引入图片

```
// 监视图片是否出现在可视区域内
function isInViewport(el) {
  const rect = el.getBoundingClientRect();
  return (
    rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.bottom >= 0
  );
}

// 监听滚动事件
window.addEventListener('scroll', throttle(checkImages, 200));
```

3. 防抖和节流

防抖：仅在停止触发后执行一次

节流：固定时间间隔执行一次

4. keep-alive
5. v-show复用组件
6. 组件按需导入

## vue的生命周期

vue3中的生命周期：setup, onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onActivated, onDeactivated.

vue2有两个钩子对应setup：beforeCreate和created。（vue2的生命周期钩子函数中没有on）

## Vue 子组件和父组件执行顺序

从外到内，再从内到外（before操作外->内，ed操作内到外）

**加载渲染过程：**

1. 父组件 beforeCreate
2. 父组件 created
3. 父组件 beforeMount
4. 子组件 beforeCreate
5. 子组件 created
6. 子组件 beforeMount
7. 子组件 mounted
8. 父组件 mounted

**更新过程：**

1. 父组件 beforeUpdate
2. 子组件 beforeUpdate
3. 子组件 updated
4. 父组件 updated

**销毁过程：**

1. 父组件 beforeDestroy
2. 子组件 beforeDestroy
3. 子组件 destroyed
4. 父组件 destoryed

## 路由中的hash和history区别

Vue-Router有两种模式：**hash模式**和**history模式**。默认的路由模式是hash模式。

#### 1. hash模式

**简介：** hash模式是开发中默认的模式，它的URL带着一个#，例如：http://www.abc.com/#/vue，它的hash值就是`#/vue`。

**特点**：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。

**原理：** hash模式的主要原理就是**onhashchange()事件**：

```javascript
window.onhashchange = function(event){
	console.log(event.oldURL, event.newURL);
	let hash = location.hash.slice(1);
}
```

使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。

#### 2. history模式

**简介：** history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。

**特点：** 当使用history模式时，URL就像这样：http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。

**API：** history api可以分为两大部分，切换历史状态和修改历史状态：

- **修改历史状态**：包括了 HTML5 History Interface 中新增的 `pushState()` 和 `replaceState()` 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。
- **切换历史状态：** 包括`forward()`、`back()`、`go()`三个方法，对应浏览器的前进，后退，跳转操作。

虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。

如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：

```javascript
const router = new VueRouter({
  mode: 'history',
  routes: [...]
})
```

#### 3. 两种模式对比

调用 history.pushState() 相比于直接修改 hash，存在以下优势:

- pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
- pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
- pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
- pushState() 可额外设置 title 属性供后续使用。
- hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。

## Vue-router跳转和location.href有什么区别

- 使用 `location.href= /url `来跳转，简单方便，但是刷新了页面；
- 使用 `history.pushState( /url )` ，无刷新页面，静态跳转；
- 引进 router ，然后使用 `router.push( /url )` 来跳转，使用了 `diff` 算法，实现了按需加载，减少了 dom 的消耗。还会走路由守卫，传参等步骤

## params传参和query传参的区别

params传参, 必须在路由中配置才能在$route.params中获得

```js
// 路由配置（?表示:id 可选，如果没有则必传）
{
  path: '/user/:id?',  // :id 后面的 ? 表示可选
  name: 'User'
}

// 有效导航方式
router.push({ name: 'User', params: { id: 123 } });  // URL: /user/123
router.push('/user/123');                            // 等效
router.push({ name: 'User' });                      // URL: /user（params.id 为 undefined）
```

query传参，直接在路径后拼接?xxx=xx&xxx=xx。也可以在router.push中添加query对象

## Vuex

#### 1 **State（状态）**

- 应用的数据源，类似于组件中的 `data`。
- 所有组件共享的状态存储。

#### 2 **Mutations（突变）**

- 更改 state 的唯一途径，类似于组件中的 `methods`。
- 必须是同步函数。

#### 3 **Actions（动作）**

- 处理异步操作（如 API 请求）。
- 通过触发 mutations 间接修改 state。
- 每个 action 都会接收一个 **context 对象**，它包含以下属性：
  - `state`：当前模块的 state（等同于 `store.state`）
  - `getters`：当前模块的 getters（等同于 `store.getters`）
  - `commit`：用于触发 mutations 的方法（等同于 `store.commit`）
  - `dispatch`：用于触发其他 actions 的方法（等同于 `store.dispatch`）

#### 4 **Getters（获取器）**

- 类似于组件中的 `computed`，用于获取 state 的派生数据。

```js
// store/index.js
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

export default new Vuex.Store({
  state: {
    count: 0,
    user: null
  },
  mutations: {
    increment(state) {
      state.count++;
    },
    setUser(state, user) {
      state.user = user;
    }
  },
  actions: {
    async fetchUser({ commit }) { 
      const response = await fetch('/api/user');
      const user = await response.json();
      commit('setUser', user);  // 触发 mutation
    }
  },
  getters: {
    doubleCount(state) {
      return state.count * 2;
    }
  }
});
```

```js
// 如何使用
<template>
  <div>
    Count: {{ $store.state.count }}
  </div>
</template>

<script>
export default {
  computed: {
    // 使用计算属性映射 state
    count() {
      return this.$store.state.count; // 使用state
    }
  }
}
</script>
// -------------------------------------------------------------------
<template>
  <button @click="increment">+1</button>
</template>

<script>
export default {
  methods: {
    increment() {
      this.$store.commit('increment');  // 触发 mutation，只支持同步操作，异步操作需要通过actions实现
    }
  }
}
</script>
// -------------------------------------------------------------------
<template>
  <button @click="fetchUser">获取用户</button>
</template>

<script>
export default {
  methods: {
    async fetchUser() {
      await this.$store.dispatch('fetchUser');  // 触发 action
    }
  }
}
</script>
// -------------------------------------------------------------------
<template>
  <div>
    Double Count: {{ doubleCount }}
  </div>
</template>

<script>
export default {
  computed: {
    doubleCount() {
      return this.$store.getters.doubleCount;  // 获取 getter
    }
  }
}
</script>
```

##  Vuex 和 localStorage 的区别

**（1）最重要的区别**

- vuex存储在内存中
- localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快

**（2）应用场景**

- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。
- localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。
- Vuex能做到数据的响应式，localstorage不能

**（3）永久性**

刷新页面时vuex存储的值会丢失（因为值存储在内存中，页面刷新时会充值vue实例和store），localstorage不会。建议vuex在state中的值发生变化的时候，将值存储到localstorage中，并在store初始化中，通过actions检测值是否存在并恢复。

## vue3相较于vue2的变化

使用es6的proxy替换了Object.defineProperty()，使得可以检测对象的修改和删除(vue2需要通过vue.set,vue.delete)

vue3可以使用组合式声明，对ts的支持也更好。vue2只能使用函数式声明

## 虚拟dom

从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。

## diff算法原理

在新老虚拟DOM对比时：

- 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
- 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
- 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。
- 匹配时，找到相同的子节点，递归比较子节点

在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较

## Vue中key的作用

vue 中 key 值的作用可以分为两种情况来考虑：

- 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。
- 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。

key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速

- 更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。
- 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快

# 手写

## Object.create()

在该函数中传入一个对象，从而创建一个继承自该对象的对象

```js
function create(obj) {
  function F() {}      // 1. 创建一个空的构造函数 F
  F.prototype = obj    // 2. 将 F 的原型指向传入的 obj
  return new F()       // 3. 返回 F 的实例对象，该实例对象的原型是 obj
}
```

## instanceOf

A instanceOf B,用于判断A是否是B的实例对象

```js
function myInstanceof(left, right) {
  // 获取 left 对象的原型,即__proto__属性
  let proto = Object.getPrototypeOf(left);
  // 获取 right 构造函数的 prototype 对象
  let prototype = right.prototype;

  // 在原型链上查找
  while (true) {
    if (!proto) return false;  // 到达原型链末端
    if (proto === prototype) return true;  // 找到匹配的原型
    
    // 继续向上查找原型链
    proto = Object.getPrototypeOf(proto);
  }
}
```

## new操作符

```js
function objectFactory() {
  let newObject = null; 
  let constructor = Array.prototype.shift.call(arguments); // 用于取出arguments的第一个值，同时保留剩下的
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并在对象内执行构造函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果。如果是对象或者函数类型，则直接返回，如果不是，就需要返回object包装的类型
  return flag ? result : newObject;
}
// 使用方法
objectFactory(构造函数, 初始化参数);
```

## Promise

```js
const PENDING = 'pending';
const RESOLVED = 'resolved';
const REJECTED = 'rejected';

class MyPromise {
  constructor(executor) {
    this.state = PENDING;
    this.value = undefined;
    this.resolvedCallbacks = [];
    this.rejectedCallbacks = [];

    // 使用箭头函数自动绑定 this
    const resolve = (value) => {
      // 可写可不写，用于当resolve一个promise的时候，会等待该promise执行完毕后再执行
      if (value instanceof MyPromise) {
        return value.then(resolve, reject);
      }
	// 为了实现优先执行Promise后的同步任务，在Promise内部设置宏任务
      setTimeout(() => {
        if (this.state === PENDING) {
          this.state = RESOLVED;
          this.value = value;
          this.resolvedCallbacks.forEach(cb => cb(value));
        }
      });
    };

    const reject = (reason) => {
      setTimeout(() => {
        if (this.state === PENDING) {
          this.state = REJECTED;
          this.value = reason;
          this.rejectedCallbacks.forEach(cb => cb(reason));
        }
      });
    };

    try {
      executor(resolve, reject); // 执行传入Promise的回调函数，向外暴露resolve和reject
    } catch (err) {
      reject(err);
    }
  }

  then(onResolved, onRejected) {
    // 值穿透处理
    onResolved = typeof onResolved === 'function' ? onResolved : v => v;
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };
	// Promise未执行时逻辑
    if (this.state === PENDING) {
      // 返回新 Promise 支持链式调用
      return new MyPromise((resolve, reject) => {
        // 传入回调函数，当Promise状态发生变化的时候，会取出执行
        this.resolvedCallbacks.push((value) => {
          try {
            const result = onResolved(value);
            resolve(result);
          } catch (err) {
            reject(err);
          }
        });

        this.rejectedCallbacks.push((reason) => {
          try {
            const result = onRejected(reason);
            resolve(result);
          } catch (err) {
            reject(err);
          }
        });
      });
    }

    // 状态已确定时直接执行
    return new MyPromise((resolve, reject) => {
      setTimeout(() => {
        try {
          const callback = this.state === RESOLVED ? onResolved : onRejected;
          const result = callback(this.value);
          resolve(result);
        } catch (err) {
          reject(err);
        }
      });
    });
  }
  // catch实则是语法糖
  catch(onRejected) {
    return this.then(null, onRejected);
  }
}
```

## 防抖

```js
function debounce(fn, wait) {
  let timer = null;
  
  return function(...args) {  // ⭐️ 使用 ...args 替代 arguments 
    const context = this;    // 保存下调用环境下的this（谁调用，this就指向谁）
    
    if (timer) clearTimeout(timer);
    
    timer = setTimeout(() => {   // setTimeout会返回一个计时器id，用于取消计时器
      fn.apply(context, args); // 传递保存的参数
    }, wait);
  };
}

let callDebounce = doubounce(hello,300);
callDebounce('hello');  // hello 就是传入的arguments
```

## 节流

```js
// 函数节流的实现;
function throttle(fn, delay) {
  let curTime = Date.now();

  return function() {
    let context = this,
        args = arguments,
        nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - curTime >= delay) {
      curTime = Date.now();
      return fn.apply(context, args);
    }
  };
}
```

## 类型判断

typeof的痛点：typeof null 会返回object，对部分引用类型，返回类型均为object

```
function getType(value) {
  if (value === null) return "null";
  
  const type = typeof value;
  if (type !== "object") return type;
  
  // 引用类型统一处理
  return Object.prototype.toString.call(value) // 该函数会返回[object xxx]
    .slice(8, -1) // 直接截取 "Array"、"Date" 等
    .toLowerCase();
}
```

## call

```js
// call函数实现
Function.prototype.myCall = function(context, ...args) {
  // 类型检查：确保调用 myCall 的是一个函数（this指向）
  if (typeof this !== 'function') {
    throw new TypeError('Not a function');
  }
  // 处理 context：如果为 null/undefined，则指向全局对象（浏览器中是 window）。??操作符：当左侧为null或undefined时返回右侧
  context = context ?? window;
  // 使用唯一的 Symbol 作为属性名，避免冲突
  const fnSymbol = Symbol('fn');
  context[fnSymbol] = this; // 将原函数挂载为 context 的临时方法
  // 执行函数并传递参数，保存结果
  const result = context[fnSymbol](...args);
  // 删除临时属性，避免污染 context 对象
  delete context[fnSymbol];
  return result;
};
```

## apply

```js
Function.prototype.myApply = function(context) {
    // 确保调用 myApply 的是一个函数
    if (typeof this !== 'function') {
        throw new TypeError('当前对象不是函数');
    }

    // 处理 context，若为 null/undefined 则指向全局对象
    context = context ?? window;

    // 使用 Symbol 避免属性名冲突
    const fnSymbol = Symbol('fn');
    context[fnSymbol] = this;

    // 获取参数数组（第二个参数为数组或 undefined）
    const args = arguments[1]; // 不传参为undefined

    // 执行函数并传递参数
    let result;
    if (args === undefined || args === null) {
        // 无参数或参数为 null/undefined 时直接调用
        result = context[fnSymbol]();
    } else {
        // 确保参数是数组类型
        if (!Array.isArray(args)) {
            throw new TypeError('第二个参数必须是数组或类数组对象');
        }
        // 使用扩展运算符展开参数数组
        result = context[fnSymbol](...args);
    }

    // 删除临时属性，避免污染 context
    delete context[fnSymbol];

    return result;
};
```

## bind

```js
Function.prototype.myBind = function(context, ...presetArgs) {
  const originalFunc = this;
  const boundFunc = function(...callArgs) {
    const allArgs = [...presetArgs, ...callArgs];
    // 使用 Reflect.construct 确保实例继承自 boundFunc.prototype
    if (this instanceof boundFunc) {
      return Reflect.construct(originalFunc, allArgs, boundFunc);
    }
    // 普通调用时绑定 context
    return originalFunc.apply(context, allArgs);
  };
  // 使用 Object.setPrototypeOf 确保 boundFunc 继承 originalFunc 的静态属性
  Object.setPrototypeOf(boundFunc, Object.getPrototypeOf(originalFunc));
  return boundFunc;
};
```

## 函数柯里化

将一个需要传入多个参数的函数，分成可以接受任意数量参数的函数，直到参数数量符合原函数要求后才执行原函数

```js
function curry(fn, args) {
  // 获取函数需要的参数长度
  let length = fn.length;

  args = args || [];

  return function() {
    // 浅拷贝参数，从而不影响原先参数
    let subArgs = args.slice(0);

    // 拼接得到现有的所有参数，arguments是当前传入的参数
    for (let i = 0; i < arguments.length; i++) {
      subArgs.push(arguments[i]);
    }

    // 判断参数的长度是否已经满足函数所需参数的长度
    if (subArgs.length >= length) {
      // 如果满足，执行函数
      return fn.apply(this, subArgs);
    } else {
      // 如果不满足，递归返回科里化的函数，等待参数的传入
      // 每次调用该方法都会重走上面的逻辑
      return curry.call(this, fn, subArgs); 
    }
  };
}

// es6 实现
function curry(fn, ...args) {
  return fn.length <= args.length ? fn(...args) : curry.bind(null, fn, ...args);
}
```

## 实现浅拷贝

- Object.assign(target,param1,param2,...)
- 扩展运算符(...)
- 数组浅拷贝,两个方法不传入任何参数就是实现数组的浅拷贝
  - .slice()
  - .concat()

```js
// 手撕浅拷贝
function shallowCopy(object) {
  // 只拷贝对象
  if (!object || typeof object !== "object") return;

  // 根据 object 的类型判断是新建一个数组还是对象
  let newObject = Array.isArray(object) ? [] : {};

  // 遍历 object，并且判断是 object 的属性才拷贝，如果是object[key]，会访问原型链上的属性
  for (let key in object) {
    if (Object.hasOwnProperty.call(obj, key)) {
      newObject[key] = object[key];
    }
  }

  return newObject;
}
```

## 实现深拷贝

- `JSON.parse(JSON.stringify(obj))`,但是存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过`JSON.stringify()`进行处理之后，都会消失。

- lodash的_.cloneDeep方法

- ```js
  // 深拷贝的实现
  function deepCopy(object) {
    if (!object || typeof object !== "object") return;
  
    let newObject = Array.isArray(object) ? [] : {};
  
    for (let key in object) {
      if (Object.hasOwnProperty.call(obj, key)))) {
        newObject[key] =
          typeof object[key] === "object" ? deepCopy(object[key]) : object[key]; // 如果是对象的话，递归调用
      }
    }
  
    return newObject;
  }
  ```

## object.assign()

```js
Object.myAssign = function(target, ...sources) {
  if (target == null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }
  // 使用Object包装target，避免target是String或者Number
  const result = Object(target);
  // 遍历source，并将属性添加到target上
  sources.forEach(obj => {
    if (obj != null) {
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          result[key] = obj[key];
        }
      }
    }
  });
  return result;
};
```

## 数组扁平化

相当于实现es6中的flat功能

```js
// 递归实现
let arr = [1, [2, [3, 4, 5]]];
function flatten(arr) {
  let result = [];

  for(let i = 0; i < arr.length; i++) {
    if(Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i])); // 递归子数组
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
flatten(arr);  //  [1, 2, 3, 4，5]
```

```js
// 扩展运算符实现
let arr = [1, [2, [3, 4]]];
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) { // 查看每次遍历的数组是否还有子数组，...操作符可以解构子数组
        arr = [].concat(...arr);
    }
    return arr;
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]
```

```js
// toString会将数组递归的形成字符串，然后再通过,分割
let arr = [1, [2, [3, 4]]];
function flatten(arr) {
    return arr.toString().split(',');
}
console.log(flatten(arr)); //  [1, 2, 3, 4，5]
```

## 数组去重

```js
// es6，使用set和Array.from
const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];
Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]
```

```js
const array = [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];
uniqueArray(array); // [1, 2, 3, 5, 9, 8]
function uniqueArray(array) {
  let map = {};
  let res = [];
  for(var i = 0; i < array.length; i++) {
    if(!map.hasOwnProperty([array[i]])) {
      map[array[i]] = 1;
      res.push(array[i]);
    }
  }
  return res;
}
```

## 字符串repeat

```js
function repeat(s, n) {
    return (new Array(n + 1)).join(s); // new Array(n+1)会构造一个[,,...,]的数组，可容纳n+1个元素，.join(s)方法可以让数组中的元素以s连接起来，最后构成n个s相连
}
```

## 红绿灯

```js
// 定义Promise
const task = (timer, light) => 
    new Promise((resolve, reject) => {
        setTimeout(() => {
            if (light === 'red') {
                red()
            }
            else if (light === 'green') {
                green()
            }
            else if (light === 'yellow') {
                yellow()
            }
            resolve()
        }, timer)
    })

// 使用.then递归实现
const step = () => {
    task(3000, 'red')
        .then(() => task(2000, 'green'))
        .then(() => task(1000, 'yellow'))
        .then(step) // 循环调用
}
step()

// 使用async/await
const taskRunner =  async () => {
    await task(3000, 'red')
    await task(1000, 'green')
    await task(2000, 'yellow')
    taskRunner()  // 循环调用
}
taskRunner()
```

## 约瑟夫环

```js
function josephus(n, m) {
    // 常用生成数组方法，第一个参数是生成了一个类数组，第二个参数是mapFn，箭头函数的参数是(值，索引)
    const people = Array.from({ length: n }, (_, i) => i + 1); // 初始化编号1~n
    let index = 0; // 当前报数位置

    for (let i = n; i > 1; i--) { // 直到剩下1人
        index = (index + m - 1) % i; // 计算下一个淘汰者的索引（从0开始）
        people.splice(index, 1); // 淘汰该人
    }
    return people[0]; // 返回幸存者
}
console.log(josephus(5, 3)); // 输出: 4
```

